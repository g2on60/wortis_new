// ignore_for_file: use_build_context_synchronously
import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:app_tracking_transparency/app_tracking_transparency.dart';
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';

import 'package:wortis/class/dataprovider.dart';
import 'package:wortis/class/permission_manager.dart';
import 'package:wortis/pages/connexion/gestionCompte.dart';
import 'package:wortis/class/theme_provider.dart';
import 'package:wortis/class/class.dart';
import 'package:wortis/pages/homepage.dart';

final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();
final RouteObserver<PageRoute> routeObserver = RouteObserver<PageRoute>(); 

// ========== SERVICE GLOBAL DE G√âOLOCALISATION ==========
class GlobalLocationService {
  static final GlobalLocationService _instance = GlobalLocationService._internal();
  factory GlobalLocationService() => _instance;
  GlobalLocationService._internal();

  // √âtat global de la g√©olocalisation
  LocationResult? _globalLocationResult;
  bool _isInitialized = false;
  bool _isDetecting = false;
  DateTime? _detectionTime;
  
  // Getters publics
  LocationResult? get currentLocation => _globalLocationResult;
  bool get isInitialized => _isInitialized;
  bool get isDetecting => _isDetecting;
  
  /// Initialiser la g√©olocalisation au d√©marrage de l'application
  Future<void> initializeLocationAtStartup() async {
    if (_isInitialized || _isDetecting) {
      //print('üåç [GlobalLocationService] D√©j√† initialis√© ou en cours de d√©tection');
      return;
    }
    
    _isDetecting = true;
    //print('üöÄ [GlobalLocationService] === D√âBUT INITIALISATION G√âOLOCALISATION ===');
    
    try {
      // Effectuer la d√©tection compl√®te
      final result = await _performCompleteLocationDetection();
      
      // Stocker le r√©sultat globalement
      _globalLocationResult = result;
      _isInitialized = true;
      _detectionTime = DateTime.now();
      
      //print('‚úÖ [GlobalLocationService] === INITIALISATION TERMIN√âE ===');
      //print('üìç Pays d√©tect√©: ${result.country.name} (${result.country.code})');
      //print('üîÑ Statut: ${result.status}');
      //print('üìù M√©thode: ${result.detectionMethod ?? "Non sp√©cifi√©e"}');
      
    } catch (e) {
      //print('‚ùå [GlobalLocationService] Erreur lors de l\'initialisation: $e');
      
      // Fallback en cas d'erreur critique
      _globalLocationResult = LocationResult.error(
        country: _getDefaultCountry(),
        error: 'Erreur lors de l\'initialisation: $e',
      );
      _isInitialized = true;
      
    } finally {
      _isDetecting = false;
    }
  }
  
  /// Effectuer la d√©tection compl√®te de g√©olocalisation
  Future<LocationResult> _performCompleteLocationDetection() async {
    try {
      //print('üîç [GlobalLocationService] D√©but d√©tection compl√®te...');
      
      // 1. V√©rifier et demander les permissions
      bool hasPermission = await _checkAndRequestLocationPermissions();
      if (!hasPermission) {
        //print('‚ùå [GlobalLocationService] Permissions de localisation refus√©es');
        return LocationResult.fallback(
          country: _getDefaultCountry(),
          reason: 'Permissions de localisation refus√©es',
        );
      }
      //print('‚úÖ [GlobalLocationService] Permissions accord√©es');

      // 2. V√©rifier si les services de localisation sont activ√©s
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        //print('‚ùå [GlobalLocationService] Services de localisation d√©sactiv√©s');
        return LocationResult.fallback(
          country: _getDefaultCountry(),
          reason: 'Services de localisation d√©sactiv√©s',
        );
      }
      //print('‚úÖ [GlobalLocationService] Services de localisation activ√©s');

      // 3. Obtenir la position GPS
      Position? position = await _getCurrentGPSPosition();
      
      if (position != null) {
        //print('üìç [GlobalLocationService] Position GPS obtenue: ${position.latitude}, ${position.longitude}');
        //print('‚è∞ Timestamp: ${position.timestamp}');
        //print('üéØ Pr√©cision: ${position.accuracy}m');
        
        // 4. D√©tection g√©ographique hors ligne (prioritaire)
        Country? detectedCountry = _detectCountryOffline(position.latitude, position.longitude);
        
        if (detectedCountry != null) {
          //print('üéØ [GlobalLocationService] Pays d√©tect√© via g√©ographie hors ligne: ${detectedCountry.name}');
          return LocationResult.success(
            country: detectedCountry,
            position: position,
            detectionMethod: 'GPS + G√©ographie mondiale hors ligne',
          );
        }
        
        // 5. Fallback: G√©ocodage en ligne
        //print('üåê [GlobalLocationService] Fallback vers g√©ocodage en ligne...');
        String? countryCode = await _getCountryCodeViaGeocoding(position);
        if (countryCode != null) {
          Country? onlineCountry = _findCountryByCode(countryCode);
          if (onlineCountry != null) {
            //print('‚úÖ [GlobalLocationService] Pays d√©tect√© via g√©ocodage en ligne: ${onlineCountry.name}');
            return LocationResult.success(
              country: onlineCountry,
              position: position,
              detectionMethod: 'GPS + G√©ocodage en ligne',
            );
          }
        }
        
        // 6. Si position GPS mais aucun pays d√©tect√©
        //print('‚ö†Ô∏è [GlobalLocationService] Position GPS obtenue mais pays non identifi√©');
        return LocationResult.fallback(
          country: _getDefaultCountry(),
          reason: 'Position GPS obtenue mais pays non identifi√©',
        );
      }

      // 7. Aucune position GPS obtenue
      //print('‚ùå [GlobalLocationService] Impossible d\'obtenir la position GPS');
      return LocationResult.fallback(
        country: _getDefaultCountry(),
        reason: 'Impossible d\'obtenir la position GPS',
      );

    } catch (e) {
      //print('‚ùå [GlobalLocationService] Erreur lors de la d√©tection: $e');
      return LocationResult.error(
        country: _getDefaultCountry(),
        error: _getErrorMessage(e),
      );
    }
  }
  
  /// V√©rifier et demander les permissions de localisation
  Future<bool> _checkAndRequestLocationPermissions() async {
    try {
      //print('üîê [GlobalLocationService] V√©rification des permissions...');
      
      LocationPermission permission = await Geolocator.checkPermission();
      //print('üìã Permission actuelle: $permission');
      
      if (permission == LocationPermission.denied) {
        //print('üîî Demande de permission en cours...');
        permission = await Geolocator.requestPermission();
        //print('üìã Nouvelle permission: $permission');
      }
      
      if (permission == LocationPermission.deniedForever) {
        //print('‚ùå Permission refus√©e d√©finitivement');
        return false;
      }
      
      bool isGranted = permission == LocationPermission.whileInUse || 
                      permission == LocationPermission.always;
      
      //print('‚úÖ Permissions accord√©es: $isGranted');
      return isGranted;
             
    } catch (e) {
      //print('‚ùå [GlobalLocationService] Erreur lors de la v√©rification des permissions: $e');
      return false;
    }
  }
  
  /// Obtenir la position GPS actuelle
  Future<Position?> _getCurrentGPSPosition() async {
    try {
      //print('üõ∞Ô∏è [GlobalLocationService] Acquisition position GPS...');
      
      // Essayer d'abord la derni√®re position connue
      Position? lastPosition = await Geolocator.getLastKnownPosition(
        forceAndroidLocationManager: false,
      );
      
      if (lastPosition != null) {
        final age = DateTime.now().difference(lastPosition.timestamp!);
        //print('üìç Derni√®re position trouv√©e (${age.inMinutes} minutes)');
        
        if (age.inMinutes <= 15) { // Position r√©cente acceptable
          //print('‚úÖ Utilisation de la derni√®re position connue');
          return lastPosition;
        } else {
          //print('‚è∞ Derni√®re position trop ancienne, acquisition nouvelle position...');
        }
      } else {
        //print('üìç Aucune derni√®re position disponible');
      }
      
      // Obtenir une nouvelle position GPS
      //print('üéØ Acquisition nouvelle position GPS...');
      Position currentPosition = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 20),
        forceAndroidLocationManager: false,
      ).timeout(const Duration(seconds: 25));
      
      //print('‚úÖ Nouvelle position GPS acquise');
      return currentPosition;
      
    } catch (e) {
      //print('‚ùå [GlobalLocationService] Erreur acquisition GPS: $e');
      return null;
    }
  }
  
  /// D√©tection g√©ographique hors ligne
  Country? _detectCountryOffline(double latitude, double longitude) {
    try {
      //print('üó∫Ô∏è [GlobalLocationService] D√©tection g√©ographique hors ligne...');
      
      // Utiliser votre syst√®me de d√©tection g√©ographique hors ligne existant
      return GlobalOfflineGeocoding.detectCountryFromCoordinates(latitude, longitude);
      
    } catch (e) {
      //print('‚ùå [GlobalLocationService] Erreur d√©tection hors ligne: $e');
      return null;
    }
  }
  
  /// G√©ocodage en ligne pour obtenir le code pays
  Future<String?> _getCountryCodeViaGeocoding(Position position) async {
    try {
      //print('üåê [GlobalLocationService] G√©ocodage en ligne...');
      
      List<Placemark> placemarks = await placemarkFromCoordinates(
        position.latitude,
        position.longitude,
      ).timeout(const Duration(seconds: 10));

      if (placemarks.isNotEmpty) {
        final placemark = placemarks.first;
        //print('üè∑Ô∏è G√©ocodage: ${placemark.country} (${placemark.isoCountryCode})');
        return placemark.isoCountryCode;
      }
      
      //print('‚ùå Aucun r√©sultat de g√©ocodage');
      return null;
      
    } catch (e) {
      //print('‚ùå [GlobalLocationService] Erreur g√©ocodage: $e');
      return null;
    }
  }
  
  /// Trouver un pays par son code ISO
  Country? _findCountryByCode(String? countryCode) {
    if (countryCode == null || countryCode.isEmpty) return null;
    
    try {
      return countries.firstWhere(
        (country) => country.code.toLowerCase() == countryCode.toLowerCase(),
        orElse: () => _getDefaultCountry(),
      );
    } catch (e) {
      //print('‚ùå [GlobalLocationService] Pays non trouv√© pour le code: $countryCode');
      return _getDefaultCountry();
    }
  }
  
  /// Obtenir le pays par d√©faut
  Country _getDefaultCountry() {
    if (countries.isNotEmpty) {
      return countries.first; // Congo par d√©faut
    }
    return const Country(
      name: 'Congo', 
      code: 'CG', 
      dialCode: '+242', 
      flag: 'üá®üá¨'
    );
  }
  
  /// G√©n√©rer un message d'erreur user-friendly
  String _getErrorMessage(dynamic error) {
    final errorStr = error.toString().toLowerCase();
    
    if (errorStr.contains('permission')) {
      return 'Permission de localisation requise';
    } else if (errorStr.contains('service')) {
      return 'Services de localisation d√©sactiv√©s';
    } else if (errorStr.contains('timeout')) {
      return 'D√©lai de d√©tection d√©pass√©';
    } else if (errorStr.contains('network') || errorStr.contains('io_error')) {
      return 'Erreur de r√©seau';
    } else {
      return 'Erreur de g√©olocalisation';
    }
  }
  
  /// Forcer une nouvelle d√©tection (pour refresh manuel)
  Future<LocationResult> refreshLocation() async {
    //print('üîÑ [GlobalLocationService] Refresh de la g√©olocalisation demand√©');
    
    if (_isDetecting) {
      //print('‚è≥ D√©tection d√©j√† en cours, attente...');
      
      // Attendre que la d√©tection en cours se termine
      int attempts = 0;
      while (_isDetecting && attempts < 20) { // Max 10 secondes
        await Future.delayed(const Duration(milliseconds: 500));
        attempts++;
      }
      
      return _globalLocationResult ?? LocationResult.fallback(
        country: _getDefaultCountry(),
        reason: 'Timeout lors de l\'attente',
      );
    }
    
    // Effectuer une nouvelle d√©tection
    _isDetecting = true;
    
    try {
      final result = await _performCompleteLocationDetection();
      _globalLocationResult = result;
      _detectionTime = DateTime.now();
      return result;
    } finally {
      _isDetecting = false;
    }
  }
  
  /// Vider le cache (pour forcer une nouvelle d√©tection)
  void clearCache() {
    //print('üóëÔ∏è [GlobalLocationService] Cache vid√©');
    _globalLocationResult = null;
    _detectionTime = null;
    _isInitialized = false;
  }
}

// ========== FONCTION MAIN ==========
void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  //print('üöÄ [MAIN] === D√âMARRAGE APPLICATION ===');
  
  // 2. Demander les autres permissions (ATT, notifications, etc.)
  //print('üîê [MAIN] Demande des autres permissions...');
  await PermissionManager.requestModernPermissions(null);

  final navigatorKey = GlobalKey<NavigatorState>();

  //print('üì± [MAIN] Lancement de l\'interface utilisateur...');
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (_) => AppDataProvider(navigatorKey: navigatorKey),
        ),
        ChangeNotifierProvider(create: (_) => ThemeProvider()),
      ],
      child: MyApp(navigatorKey: navigatorKey),
    ),
  );
}

class MyApp extends StatelessWidget {
  final GlobalKey<NavigatorState> navigatorKey;
  
  const MyApp({required this.navigatorKey, super.key});

  @override 
  Widget build(BuildContext context) {
    return Consumer<ThemeProvider>(
      builder: (context, themeProvider, _) {
        return MaterialApp(
          navigatorKey: navigatorKey,
          routes: {
            '/home': (context) => HomePage(routeObserver: routeObserver),
          },
          title: 'Wortis',
          debugShowCheckedModeBanner: false,
          navigatorObservers: [routeObserver],
          theme: themeProvider.getLightTheme(),
          darkTheme: themeProvider.getDarkTheme(),
          themeMode: themeProvider.isDarkMode ? ThemeMode.dark : ThemeMode.light,
          home: const IntroPage(),
        );
      },
    );
  }
}

class IntroPage extends StatefulWidget {
  const IntroPage({super.key});

  @override
  State<IntroPage> createState() => _IntroPageState();
}

class _IntroPageState extends State<IntroPage> with SingleTickerProviderStateMixin {
  bool _isLoading = true;
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(seconds: 4),
      vsync: this,
    );
    
    _initializeAnimation();
    _initialize();
  }

  Future<void> _requestTrackingPermission() async {
    // V√©rifiez d'abord si vous utilisez iOS
    if (Platform.isIOS) {
      // V√©rifiez le statut actuel
      final status = await AppTrackingTransparency.trackingAuthorizationStatus;
      
      // Si le statut est ind√©termin√©, demandez l'autorisation
      if (status == TrackingStatus.notDetermined) {
        // Attendez que l'app soit compl√®tement initialis√©e sur iOS
        await Future.delayed(const Duration(milliseconds: 500));
        
        // Demandez l'autorisation
        final result = await AppTrackingTransparency.requestTrackingAuthorization();
        //print('Tracking permission status: $result');
      }
    }
  }

  Future<void> _initialize() async {
    try {
      //print('üîÑ [IntroPage] D√©but initialisation...');
      
      // 1. D√©marrer la g√©olocalisation en arri√®re-plan en m√™me temps que le chargement
      final locationFuture = GlobalLocationService().initializeLocationAtStartup();
      
      // 2. Demander l'autorisation ATT en premier sur iOS
      await _requestTrackingPermission();
      
      final appDataProvider = Provider.of<AppDataProvider>(context, listen: false);
      
      // 3. Obtenir le token de mani√®re s√©curis√©e
      String? token;
      try {
        token = await SessionManager.getToken();
      } catch (e) {
        //print('Erreur lors de la r√©cup√©ration du token: $e');
        token = null;
      }
      
      // 4. Attendre que la g√©olocalisation se termine
      await locationFuture;
      //print('‚úÖ [IntroPage] G√©olocalisation termin√©e pendant le chargement');
      
      if (token == null || token.isEmpty) {
        // Si pas de token, charger uniquement les donn√©es publiques et naviguer vers auth
        try {
          await appDataProvider.loadPublicDataWithPriority();
        } catch (e) {
          //print('Erreur lors du chargement des donn√©es publiques: $e');
        }
        
        if (mounted) {
          setState(() => _isLoading = false);
          _navigateToAuth();
        }
        return;
      }
      
      // Pour les utilisateurs connect√©s
      const timeout = Duration(seconds: 8);
      bool isTokenValid = false;
      bool timeoutOccurred = false;
      
      try {
        // V√©rifier la validit√© du token avec timeout
        isTokenValid = await _verifyTokenValidity(token).timeout(
          timeout,
          onTimeout: () {
            timeoutOccurred = true;
            return false;
          },
        );
        
        // Charger les donn√©es publiques en parall√®le
        final dataLoadingFuture = appDataProvider.loadPublicDataWithPriority();
        
        if (!isTokenValid || timeoutOccurred) {
          // Token invalide ou timeout
          await dataLoadingFuture;
          if (mounted) {
            setState(() => _isLoading = false);
            _navigateToAuth();
          }
          return;
        }
        
        // Si le token est valide, attendre le chargement des donn√©es publiques
        await dataLoadingFuture;
        
        if (mounted) {
          setState(() => _isLoading = false);
          _navigateToHome();
          
          // Charger les d√©tails utilisateur en arri√®re-plan apr√®s navigation
          Future.microtask(() => appDataProvider.loadUserProfileInBackground(token!));
        }
        
      } catch (e) {
        //print('Erreur lors de la v√©rification du token: $e');
        // En cas d'erreur, charger quand m√™me les donn√©es publiques et rediriger
        try {
          await appDataProvider.loadPublicDataWithPriority();
        } catch (loadError) {
          //print('Erreur lors du chargement des donn√©es publiques: $loadError');
        }
        
        if (mounted) {
          setState(() => _isLoading = false);
          _navigateToAuth();
        }
      }
      
    } catch (e) {
      //print('Erreur g√©n√©rale dans _initialize: $e');
      if (mounted) {
        setState(() => _isLoading = false);
        _navigateToAuth();
      }
    }
  }

  Future<bool> _verifyTokenValidity(String token) async {
    try {
      final storedToken = await SessionManager.getToken();
      
      if (storedToken != null) {
        return token == storedToken;
      }
      
      return false;
    } catch (e) {
      return false;
    }
  }

  void _navigateToHome() {
    if (!mounted) return;
    Navigator.pushReplacementNamed(context, '/home');
  }

  void _navigateToAuth() {
    if (!mounted) return;
    Navigator.pushReplacement(
      context,
      MaterialPageRoute(builder: (context) => const AuthentificationPage()),
    );
  }

  void _initializeAnimation() {
    _scaleAnimation = TweenSequence<double>([
      TweenSequenceItem(
        tween: Tween<double>(begin: 0.0, end: 1.2)
            .chain(CurveTween(curve: Curves.easeOut)),
        weight: 60.0,
      ),
      TweenSequenceItem(
        tween: Tween<double>(begin: 1.2, end: 1.0)
            .chain(CurveTween(curve: Curves.easeInOut)),
        weight: 40.0,
      ),
    ]).animate(_animationController);

    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(
      CurvedAnimation(
        parent: _animationController,
        curve: const Interval(0.0, 0.6, curve: Curves.easeIn),
      ),
    );

    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF006699),
      body: Stack(
        children: [
          _buildBackground(),
          _buildLogo(),
          if (_isLoading) _buildLoadingIndicator(),
        ],
      ),
    );
  }

  Widget _buildBackground() {
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            const Color(0xFF006699),
            const Color(0xFF006699).withOpacity(0.8),
            const Color(0xFF006699).withOpacity(0.6),
          ],
        ),
      ),
    );
  }

  Widget _buildLogo() {
    return Center(
      child: AnimatedBuilder(
        animation: _animationController,
        builder: (context, child) {
          return Transform.scale(
            scale: _scaleAnimation.value,
            child: Opacity(
              opacity: _opacityAnimation.value,
              child: Container(
                padding: const EdgeInsets.all(20),
                child: Image.asset(
                  'assets/wortisapp.png',
                  height: 200,
                  width: 200,
                  fit: BoxFit.contain,
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildLoadingIndicator() {
    return const Positioned(
      bottom: 50,
      left: 0,
      right: 0,
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                strokeWidth: 2,
              ),
            ),
            SizedBox(height: 10),
            Text(
              'Chargement...',
              style: TextStyle(color: Colors.white, fontSize: 12),
            ),
          ],
        ),
      ),
    );
  }
}